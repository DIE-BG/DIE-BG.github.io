{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Cómputo de los Errores Condicionales\"\n",
        "author: \"DIE\"\n",
        "format: \n",
        "    revealjs:\n",
        "        scrollable: true\n",
        "        incremental: false\n",
        "        slide-number: true\n",
        "        smaller: true\n",
        "        progress: true\n",
        "        controls: true\n",
        "        controls-back-arrows: faded\n",
        "        center: true\n",
        "---\n",
        "\n",
        "```{css, echo=FALSE}\n",
        ".reveal code {\n",
        "  max-height: 100% !important;\n",
        "}\n",
        "```\n",
        "\n",
        "\n",
        "El cálculo de los errores condicionales se fundamenta en el documento *\"Criteria for SVAR Model Selection: A Proposal\"*, el cual introduce una notación específica para organizar los conjuntos de datos y los resultados derivados del modelo.\n",
        "\n",
        "## Repaso de Notación\n",
        "\n",
        "---\n",
        "\n",
        "Se denota por $t$ el índice de tiempo, el cual puede tomar valores dentro del conjunto $\\lbrace 0, 1, \\dots, T, T+1, T+2, \\dots, V \\rbrace$.\n",
        "\n",
        "A partir de esta secuencia, se definen dos subconjuntos relevantes: el conjunto de entrenamiento \n",
        "\n",
        "$$\n",
        "\\mathcal{T} = \\lbrace 0, 1, \\dots, T \\rbrace\n",
        "$$ \n",
        "\n",
        "y el conjunto de validación \n",
        "\n",
        "$$\n",
        "\\mathcal{V} = \\lbrace T+1, T+2, \\dots, V \\rbrace\n",
        "$$\n",
        "\n",
        "---\n",
        "\n",
        "A partir del *conjunto de entrenamiento*, se estiman los parámetros: $\\hat{A}_{0, \\mathcal{T}}$, $\\hat{A}_{1, \\mathcal{T}}$ y $\\hat{B}_{0, \\mathcal{T}}$. \n",
        "\n",
        "Estos parámetros permiten generar pronósticos incondicionales (**fuera de muestra**) a horizonte 1, definidos como \n",
        "\n",
        "$$\n",
        "\\hat{y}_{t|t-1,u,\\mathcal{T},\\mathcal{V}} = \\hat{A}_{0, \\mathcal{T}} + \\hat{A}_{1, \\mathcal{T}} y_{t-1}\n",
        "$$ \n",
        "\n",
        "para todo $t$ en el conjunto de validación $\\mathcal{V}$.\n",
        "\n",
        "La diferencia entre los valores observados $y_t$ y sus pronósticos genera los residuos incondicionales \n",
        "\n",
        "$$\n",
        "\\hat{e}_{t|t-1,u,\\mathcal{T},\\mathcal{V}} = y_t - \\hat{y}_{t|t-1,u,\\mathcal{T},\\mathcal{V}}\n",
        "$$\n",
        "\n",
        "Aplicando la matriz $\\hat{B}_{0, \\mathcal{T}}$ sobre estos residuos se obtienen los choques estructurales correspondientes al pronóstico incondicional: \n",
        "\n",
        "$$\n",
        "\\hat{w}_{t|t-1,\\mathcal{T},\\mathcal{V}} = \\hat{B}_{0, \\mathcal{T}} \\hat{e}_{t|t-1,u,\\mathcal{T},\\mathcal{V}}\n",
        "$$\n",
        "\n",
        "---\n",
        "\n",
        "Adicionalmente, se estiman en el *conjunto de validación*: $\\hat{A}_{0, \\mathcal{V}}$, $\\hat{A}_{1, \\mathcal{V}}$ y $\\hat{B}_{0, \\mathcal{V}}$. \n",
        "\n",
        "Estos parámetros permiten generar pronósticos incondicionales (**dentro de muestra**) a horizonte 1, definidos como \n",
        "\n",
        "$$\n",
        "\\hat{y}_{t|t-1,u,\\mathcal{V},\\mathcal{V}} = \\hat{A}_{0, \\mathcal{V}} + \\hat{A}_{1, \\mathcal{V}} y_{t-1}\n",
        "$$ \n",
        "\n",
        "para todo $t$ en el conjunto de validación $\\mathcal{V}$.\n",
        "\n",
        "A partir de estos pronósticos dentro de muestra se calculan los correspondientes residuos:\n",
        "\n",
        "$$\n",
        "\\hat{e}_{t|t-1,u,\\mathcal{V},\\mathcal{V}} = y_t - \\hat{y}_{t|t-1,u,\\mathcal{V},\\mathcal{V}}\n",
        "$$\n",
        "\n",
        "Y aplicando la matriz $\\hat{B}_{0, \\mathcal{V}}$ sobre estos residuos se obtienen los choques estructurales correspondientes: \n",
        "\n",
        "$$\n",
        "\\hat{w}_{t|t-1,\\mathcal{V},\\mathcal{V}} = \\hat{B}_{0, \\mathcal{V}} \\hat{e}_{t|t-1,u,\\mathcal{V},\\mathcal{V}}\n",
        "$$\n",
        "\n",
        "---\n",
        "\n",
        "Los **errores condicionales** son, entonces:\n",
        "\n",
        "$$\n",
        "\\hat{e}_{t|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}} = \n",
        "    y_t - \\hat{y}_{t|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}}, \\, \\forall t \\in \\mathcal{V}\n",
        "$$\n",
        "\n",
        "en donde el pronóstico condicional $\\hat{y}_{t,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}}$ se define como:\n",
        "\n",
        "$$\n",
        "\\hat{y}_{t|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}} = \n",
        "    \\hat{A}_{0, \\mathcal{T}} + \\hat{A}_{1, \\mathcal{T}} y_{t-1} +\n",
        "    \\hat{B}_{0, \\mathcal{T}}^{-1} \\hat{w}_{t|t-1,\\mathcal{V},\\mathcal{V}}, \\, \\forall t \\in \\mathcal{V}\n",
        "$$\n",
        "\n",
        "## Algoritmo de Cómputo\n",
        "\n",
        "---\n",
        "\n",
        "Para computar los errores condicionales, requerimos:\n",
        "\n",
        "- Una muestra de estimación $\\mathcal{T}$.\n",
        "- Una muestra de validación $\\mathcal{V}$.\n",
        "- Una parametrización en la muestra de estimación: $\\hat{A}_{0, \\mathcal{T}}$, $\\hat{A}_{1, \\mathcal{T}}$ y $\\hat{B}_{0, \\mathcal{T}}$.\n",
        "- Una parametrización en la muestra de validación: $\\hat{A}_{0, \\mathcal{V}}$, $\\hat{A}_{1, \\mathcal{V}}$ y $\\hat{B}_{0, \\mathcal{V}}$.\n",
        "- Los choques estructurales computados a partir de la parametrización en la muestra de validación $\\mathcal{V}$, y los pronósticos dentro de muestra en el mismo conjunto de validación: $\\hat{w}_{t,\\mathcal{V},\\mathcal{V}}$.\n",
        "\n",
        "---\n",
        "\n",
        "Con estos componentes, el objetivo es calcular \n",
        "\n",
        "$$\n",
        "\\hat{e}_{t|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}} = \n",
        "    y_t - \\hat{y}_{t|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}}, \\, \\forall t \\in \\mathcal{V}\n",
        "$$\n",
        "\n",
        "Sin embargo, también estamos interesados en los errores condicionales a horizontes mayores, es decir:\n",
        "\n",
        "$$\n",
        "\\hat{e}_{t+1|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}} = \n",
        "    y_{t+1} - \\hat{y}_{t+1|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}}, \\, \\forall t+1 \\in \\mathcal{V}\n",
        "$$\n",
        "\n",
        "$$\n",
        "\\hat{e}_{t+2|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}} = \n",
        "    y_{t+2} - \\hat{y}_{t+2|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}}, \\, \\forall t+2 \\in \\mathcal{V}\n",
        "$$\n",
        "$$\n",
        "\\vdots\n",
        "$$\n",
        "\n",
        "Todos estos errores comparten la misma condición inicial en $t-1$, y se diferencian únicamente en el horizonte de validación.\n",
        "\n",
        "¿Cómo se genera un error de pronóstico condicional a un horizonte $h$, $\\hat{e}_{t+h-1|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}}$?\n",
        "\n",
        "---\n",
        "\n",
        "1. Primero, necesitamos calcular los choques estructurales en la muestra de validación con parametrización en la misma muestra: $\\hat{w}_{t+h-1|t-1,\\mathcal{V},\\mathcal{V}}$.\n",
        "\n",
        "$$\n",
        "\\hat{y}_{t+h-1|t-1,u,\\mathcal{V},\\mathcal{V}} = \n",
        "    \\hat{A}_{1, \\mathcal{V}}^h y_{t-1} + \n",
        "    \\sum_{i=1}^{h} \\hat{A}_{1, \\mathcal{V}}^{i-1} \\hat{A}_{0, \\mathcal{V}}\n",
        "$$ \n",
        "\n",
        "$$\n",
        "\\hat{e}_{t+h-1|t-1,u,\\mathcal{V},\\mathcal{V}} = y_{t+h-1} - \\hat{y}_{t+h-1|t-1,u,\\mathcal{V},\\mathcal{V}}\n",
        "$$\n",
        "$$\n",
        "\\hat{w}_{t+h-1|t-1,\\mathcal{V},\\mathcal{V}} = \\hat{B}_{0, \\mathcal{V}} \\hat{e}_{t+h-1|t-1,u,\\mathcal{V},\\mathcal{V}}\n",
        "$$\n",
        "\n",
        "---\n",
        "\n",
        "2. Luego, con los choques generados en la muestra de validación, generamos los pronósticos condicionales:\n",
        "\n",
        "$$\n",
        "\\hat{y}_{t+h-1|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}} = \n",
        "    \\hat{y}_{t+h-1|t-1,u,\\mathcal{T},\\mathcal{V}} +\n",
        "    \\hat{B}_{0, \\mathcal{T}}^{-1} \\hat{w}_{t+h-1|t-1,\\mathcal{V},\\mathcal{V}}\n",
        "$$\n",
        "\n",
        "$$\n",
        "\\hat{y}_{t+h-1|t-1,u,\\mathcal{T},\\mathcal{V}} = \n",
        "    \\hat{A}_{1, \\mathcal{T}}^h y_{t-1} + \n",
        "    \\sum_{i=1}^{h} \\hat{A}_{1, \\mathcal{T}}^{i-1} \\hat{A}_{0, \\mathcal{T}}\n",
        "$$ \n",
        "\n",
        "3. Con los pronósticos condicionales, podemos calcular los errores condicionales:\n",
        "\n",
        "$$\n",
        "\\hat{e}_{t+h-1|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}} = \n",
        "    y_{t+h-1} - \\hat{y}_{t+h-1|t-1,c,\\mathcal{T},\\mathcal{V},\\mathcal{V}}\n",
        "$$\n",
        "\n",
        "---\n",
        "\n",
        "Los pasos 1, 2 y 3 corresponden al procedimiento implementado en el método `computeConditionalValidationErrors`.\n",
        "\n",
        "---\n",
        "\n",
        "Una diferencia entre los modelos SVAR y aquellos utilizados en la herramienta de selección radica en las variables reconstruidas que completan las ecuaciones del modelo. \n",
        "\n",
        "Por esta razón, el método `computeConditionalValidationErrors` aprovecha las funciones `simulate` y `filter` del paquete `IRIS`, que permiten generar pronósticos condicionales para todas las variables, incluidas las reconstruidas.\n",
        "\n",
        "---\n",
        "\n",
        "La función `iris/filter` se utiliza para generar los choques en el paso 1. \n",
        "\n",
        "La dificultad radica en que esta función siempre calcula los choques condicionando en la observación anterior, es decir:\n",
        "\n",
        "| Condición Inicial | Pronóstico Incondicional | Choque calculado con `iris/filter` | Choque deseado |\n",
        "|-|-|-|-|\n",
        "$y_{t-1}$ | $\\hat{y}_{t|t-1}$ | $w_{t|t-1}$ | $w_{t|t-1}$ |\n",
        "$y_{t-1}$ | $\\hat{y}_{t+1|t-1}$ | $w_{t+1|t}$ | $w_{t+1|t-1}$ |\n",
        "$y_{t-1}$ | $\\hat{y}_{t+2|t-1}$ | $w_{t+2|t+1}$ | $w_{t+2|t-1}$ |\n",
        "$\\vdots$ | $\\vdots$ | $\\vdots$ | $\\vdots$ |\n",
        "\n",
        "---\n",
        "\n",
        "Supongamos que tenemos un `SubsampleModel` estimado entre 2005Q1 y 2015Q4. El período de validación se define de 2016Q1 a 2024Q4.\n",
        "\n",
        "En la primera iteración dentro de la muestra de validación, se tendría lo siguiente:\n",
        "\n",
        "| Condición Inicial | Pronóstico Incondicional | Choque calculado con `iris/filter` | Choque deseado |\n",
        "|-|-|-|-|\n",
        "$y_{2015Q4}$ | $\\hat{y}_{2016Q1|2015Q4}$ | $\\hat{w}_{2016Q1|2015Q4}$ | $\\hat{w}_{2016Q1|2015Q4}$ |\n",
        "$y_{2015Q4}$ | $\\hat{y}_{2016Q2|2015Q4}$ | $\\hat{w}_{2016Q2|2016Q1}$ | $\\hat{w}_{2016Q2|2015Q4}$ |\n",
        "$y_{2015Q4}$ | $\\hat{y}_{2016Q3|2015Q4}$ | $\\hat{w}_{2016Q3|2016Q2}$ | $\\hat{w}_{2016Q3|2015Q4}$ |\n",
        "$\\vdots$ | $\\vdots$ | $\\vdots$ | $\\vdots$ |\n",
        "\n",
        ":Iteración 1. Condición inicial de los pronósticos en 2015Q4\n",
        "\n",
        "---\n",
        "\n",
        "| Condición Inicial | Pronóstico Incondicional | Choque calculado con `iris/filter` | Choque deseado |\n",
        "|-|-|-|-|\n",
        "$y_{2016Q1}$ | $\\hat{y}_{2016Q2|2016Q1}$ | $\\hat{w}_{2016Q2|2016Q1}$ | $\\hat{w}_{2016Q2|2015Q4}$ |\n",
        "$y_{2016Q1}$ | $\\hat{y}_{2016Q3|2016Q1}$ | $\\hat{w}_{2016Q3|2016Q2}$ | $\\hat{w}_{2016Q3|2015Q4}$ |\n",
        "$y_{2016Q1}$ | $\\hat{y}_{2016Q4|2016Q1}$ | $\\hat{w}_{2016Q4|2016Q3}$ | $\\hat{w}_{2016Q4|2015Q4}$ |\n",
        "$\\vdots$ | $\\vdots$ | $\\vdots$ | $\\vdots$ |\n",
        "\n",
        ":Iteración 2. Condición inicial de los pronósticos en 2016Q1\n",
        "\n",
        "---\n",
        "\n",
        "Puntos importantes sobre el funcionamiento de `iris/filter`:\n",
        "\n",
        "- Aunque se actualicen las condiciones iniciales de pronóstico iterativamente, los choques calculados son siempre a horizonte 1.\n",
        "- La función no permite especificar una condición inicial distinta del dato inmediatamente anterior.\n",
        "\n",
        "Por tanto, aplicar `iris/filter` directamente no es suficiente. \n",
        "\n",
        "---\n",
        "\n",
        "La solución consiste en aplicar `iris/filter` de manera iterativa, sustituyendo las observaciones por los pronósticos incondicionales para generar el comportamiento deseado.\n",
        "\n",
        "| Nota | Condición Inicial | Pronóstico Incondicional | Choque calculado con `iris/filter` | Choque deseado |\n",
        "|-|-|-|-|-|\n",
        "|| $y_{t-1}$ | $\\hat{y}_{t|t-1}$ | $\\hat{w}_{t|t-1}$ | $\\hat{w}_{t|t-1}$ |\n",
        "| Se sustituye manualmente $y_t$ por $\\hat{y}_{t|t-1}$ y se aplica `iris/filter` por segunda vez. | $\\hat{y}_{t|t-1}$ | $\\hat{y}_{t+1|t-1}$ | $\\hat{w}_{t+1|t-1}$ | $\\hat{w}_{t+1|t-1}$ |\n",
        "|| $\\hat{y}_{t+1|t-1}$ | $\\hat{y}_{t+2|t-1}$ | $\\hat{w}_{t+2|t-1}$ | $\\hat{w}_{t+2|t-1}$ |\n",
        "|| $\\vdots$ | $\\vdots$ | $\\vdots$ | $\\vdots$ |\n",
        "\n",
        "---\n",
        "\n",
        "Una vez obtenidos los choques correctos, se ejecuta lo descrito en el paso 2, condicionando los pronósticos con `simulate` y utilizando `exogenize/endogenize`.\n",
        "\n",
        "Por defecto, `simulate` trata los choques como exógenos, por lo que basta con añadir los choques anteriores a las condiciones iniciales mediante un `dboverlay`.\n",
        "\n",
        "---\n",
        "\n",
        "Finalmente, el paso 3 es análogo a `computeValidationErrors`, calculando los errores de pronóstico condicionales.\n",
        "\n",
        "## Recorrido sobre la implementación\n",
        "\n",
        "---\n",
        "\n",
        "```matlab\n",
        "m1 = m1.computeConditionalValidationErrors(12);\n",
        "m1.modelResults.conditionalValidationErrors\n",
        "```\n",
        "\n",
        "El argumento en al función indica el horizonte de pronóstico máximo a evaluar.\n",
        "\n",
        "Por defecto este es igual a 12. \n",
        "\n",
        "---\n",
        "\n",
        "Examinando dentro de la definición de `computeConditionalValidationErrors` destacan las funciones `computeForwardShocks` y `computeConditionalForecast`, correspondientes al paso 1 y 2 del algoritmo de cómputo. \n",
        "\n",
        "```matlab\n",
        "function obj = computeConditionalValidationErrors(obj, max_horizon)\n",
        "    ...\n",
        "    tic\n",
        "    shocks_validation_insample = computeForwardShocks( ...\n",
        "        obj_validation, ...\n",
        "        obj_validation.validationStart:obj_validation.validationEnd, ...\n",
        "        model_observables, ...\n",
        "        smoothing_start_date, ...\n",
        "        max_horizon ...\n",
        "    );\n",
        "    toc\n",
        "    ...\n",
        "    tic\n",
        "    conditional_forecasted_variables = computeConditionalForecast(...\n",
        "        obj, ...\n",
        "        model_observables, ...\n",
        "        shocks_validation_insample, ...\n",
        "        max_horizon ...\n",
        "    );\n",
        "    toc\n",
        "    ...\n",
        "end   \n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "Ejemplo con un `RestrictedOLSModel`:\n",
        "\n",
        "```matlab\n",
        "m1 = ModelClasses.RestrictedOLSModel( ...\n",
        "    identifier, ...\n",
        "    data, ...\n",
        "    qq(2005, 1), ...\n",
        "    qq(2015, 4), ...\n",
        "    qq(2016, 1), ...\n",
        "    qq(2024, 4), ...\n",
        "    iris_model_path, ...\n",
        "    @setparam_SVAR50_4B, ...\n",
        "    endogenous_vars, ...\n",
        "    restriction_matrix, ... \n",
        "    estimation_options ...\n",
        ");\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "La estimación en el la muestra de validación se realiza clonando el objeto `obj` y sustituyendo la muestra de estimación por la de validación: \n",
        "\n",
        "```matlab\n",
        "function obj = computeConditionalValidationErrors(obj, max_horizon)\n",
        "    arguments\n",
        "        obj,\n",
        "        max_horizon = 12\n",
        "    end\n",
        "\n",
        "    ...\n",
        "\n",
        "    obj_validation = obj;\n",
        "    obj_validation.estimationStart = obj.validationStart;\n",
        "    obj_validation.estimationEnd = obj.validationEnd;\n",
        "    \n",
        "    fprintf('estimating the model in the validation set...\\n');\n",
        "    obj_validation = obj_validation.estimate();\n",
        "\n",
        "    ...\n",
        "\n",
        "    end\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "Comprabando que la muestra de estimación es la misma que la muestra de validación:\n",
        "\n",
        "```\n",
        "[obj_validation.estimationStart, obj_validation.validationStart]\n",
        "ans = \n",
        "\n",
        "  1x2 QUARTERLY Date(s)\n",
        "\n",
        "    {'2016Q1'}    {'2016Q1'}\n",
        "\n",
        "[obj_validation.estimationEnd, obj_validation.validationEnd]\n",
        "ans = \n",
        "\n",
        "  1x2 QUARTERLY Date(s)\n",
        "\n",
        "    {'2024Q4'}    {'2024Q4'}\n",
        "\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "El inicio de todos los filtros, por simplicidad, será la fecha inicial en los datos observados: \n",
        "\n",
        "```matlab\n",
        "smoothing_start_date = min( ...\n",
        "    structfun( ...\n",
        "        @(x) x.Range(1), ...\n",
        "        model_observables ...\n",
        "    ) ...\n",
        ");\n",
        "\n",
        "smoothing_start_date = \n",
        "\n",
        "  1x1 QUARTERLY Date(s)\n",
        "\n",
        "    {'2001Q1'}\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "`computeForwardShocks` tiene los siguientes argumentos: \n",
        "\n",
        "```matlab\n",
        "...\n",
        "\n",
        "    shocks_validation_insample = computeForwardShocks( ...\n",
        "        ... % Objeto estimado en la muestra de validación\n",
        "        obj_validation, ... \n",
        "        ... % Rango en donde vamos a calcular los choques (dentro de muestra)\n",
        "        obj_validation.validationStart:obj_validation.validationEnd, ...\n",
        "        ... % Datos observados\n",
        "        model_observables, ...\n",
        "        ... % Fecha de inicio para todos los filtros\n",
        "        smoothing_start_date, ...\n",
        "        ... % Horizonte máximo de pronóstico\n",
        "        max_horizon ...\n",
        "    );\n",
        "\n",
        "...\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "En la definición de `computeForwardShocks`, la parte más importante es el siguiente bucle:\n",
        "\n",
        "```matlab\n",
        "\n",
        "    % forward_shocks_rng fue definido en los argumentos como:\n",
        "    % obj_validation.validationStart:obj_validation.validationEnd\n",
        "    first_initial_condition_date = forward_shocks_rng(1) - 1;\n",
        "\n",
        "    m = length(forward_shocks_rng);\n",
        "    \n",
        "    for h = 1:m\n",
        "        % cada iteración de h actualiza las condiciones iniciales del pronóstico    \n",
        "        initial_condition_date = first_initial_condition_date + h - 1;\n",
        "        validation_start_date = initial_condition_date + 1;\n",
        "        validation_end_date = validation_start_date + max_horizon - 1;\n",
        "\n",
        "        % Esta rutina debe aplicarse en cada fecha de validación, ya que el \n",
        "        % filtro de Kalman solo estima shocks condicionados en t|t-1. Para lograr t|t₀,\n",
        "        % se deben actualizar manualmente las condiciones iniciales con el pronóstico incondicional.\n",
        "        tmp_observables = model_observables;\n",
        "        \n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "\n",
        "```matlab\n",
        "        for v = validation_start_date:validation_end_date\n",
        "            % Calculamos los shocks estructurales para los datos imputados en v (o t),\n",
        "            % usando `initial_condition_date` como t₀ para la condición inicial.\n",
        "            [~, s_data] = filter( ...\n",
        "                obj.irisModel, ...\n",
        "                tmp_observables, ...\n",
        "                smoothing_start_date:v, ...\n",
        "                'meanOnly=', true, ...\n",
        "                'data=', 'smooth', ...\n",
        "                'condition=', observables_names ...\n",
        "            );\n",
        "            % Pronostico incondicional\n",
        "            [~, p_data] = filter( ...\n",
        "                obj.irisModel, ...\n",
        "                tmp_observables, ...\n",
        "                smoothing_start_date:v, ...\n",
        "                'meanOnly=', true, ...\n",
        "                'data=', 'predict' ...\n",
        "            );\n",
        "            p_data = p_data * observables_names;\n",
        "            p_data = dbclip(p_data, v);\n",
        "\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "```matlab\n",
        "            % Reemplazar el valor observado en v con su pronóstico incondicional \n",
        "            % para simular un proceso de pronóstico recursivo hacia adelante.\n",
        "            tmp_observables = dboverlay( ...\n",
        "                tmp_observables, ... data with obs in v\n",
        "                p_data ... substituting the obs in v for the unconditional forecast\n",
        "            );\n",
        "            ...\n",
        "        end\n",
        "        ...\n",
        "    end\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "Si `h=1` entonces obtenemos los siguiente resultados:\n",
        "\n",
        "```\n",
        ">> first_initial_condition_date = \n",
        "\n",
        "  1x1 QUARTERLY Date(s)\n",
        "\n",
        "    {'2015Q4'}\n",
        "\n",
        ">> initial_condition_date = first_initial_condition_date + h - 1\n",
        "\n",
        "initial_condition_date = \n",
        "\n",
        "  1x1 QUARTERLY Date(s)\n",
        "\n",
        "    {'2015Q4'}\n",
        "\n",
        ">> validation_start_date = initial_condition_date + 1\n",
        "\n",
        "validation_start_date = \n",
        "\n",
        "  1x1 QUARTERLY Date(s)\n",
        "\n",
        "    {'2016Q1'}         \n",
        "\n",
        ">> validation_end_date = validation_start_date + max_horizon - 1\n",
        "\n",
        "validation_end_date = \n",
        "\n",
        "  1x1 QUARTERLY Date(s)\n",
        "\n",
        "    {'2018Q4'}\n",
        "```"
      ],
      "id": "5814c67d"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/m4wnn/miniforge3/envs/default/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}